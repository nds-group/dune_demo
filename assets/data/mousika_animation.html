<!DOCTYPE html>
<html lang="en">

<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>MOUSIKA animation</title>

   <link rel="stylesheet" href="/assets/topology_animations.css" />
   <script src="/assets/anime.min.js"></script>
</head>

<body>

   <div style="text-align: center; margin-bottom: 20px; display:none">
      <button id="play-button" style="padding: 10px 20px; display: none;">Play</button>
      <button id="pause-button" style="padding: 10px 20px;">Pause</button>
   </div>

   <div class="network-diagram">

      <?xml version="1.0" encoding="UTF-8" standalone="no"?>
      <svg viewBox="0 0 900 400" aria-labelledby="diagramTitle diagramDesc" version="1.1" id="svg10"
         sodipodi:docname="switch.svg" inkscape:version="1.4 (e7c3feb100, 2024-10-09)"
         xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
         xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg">
         <sodipodi:namedview id="namedview10" pagecolor="#ffffff" bordercolor="#000000" borderopacity="0.25"
            inkscape:showpageshadow="2" inkscape:pageopacity="0.0" inkscape:pagecheckerboard="0"
            inkscape:deskcolor="#d1d1d1" showgrid="false" inkscape:zoom="0.93804646" inkscape:cx="426.41811"
            inkscape:cy="211.60999" inkscape:window-width="1745" inkscape:window-height="1020" inkscape:window-x="0"
            inkscape:window-y="0" inkscape:window-maximized="1" inkscape:current-layer="layer1" showguides="true">
            <sodipodi:guide position="195.75405,114.15405" orientation="0,-1" id="guide22" inkscape:locked="false" />
         </sodipodi:namedview>
         <defs id="defs7">
            <inkscape:perspective sodipodi:type="inkscape:persp3d" inkscape:vp_x="977.89119 : 345.01219 : 1"
               inkscape:vp_y="0 : 1000 : 0" inkscape:vp_z="1462.6256 : 383.67229 : 1"
               inkscape:persp3d-origin="664.99065 : 74.375432 : 1" id="perspective12" />
            <linearGradient id="swatch11" inkscape:swatch="solid">
               <stop style="stop-color:#777777;stop-opacity:1;" offset="0" id="stop11" />
            </linearGradient>
            <linearGradient inkscape:collect="always" xlink:href="#swatch11" id="linearGradient11" x1="-41.931332"
               y1="41.009075" x2="84.185104" y2="41.009075" gradientUnits="userSpaceOnUse" />
            <linearGradient inkscape:collect="always" xlink:href="#swatch11" id="linearGradient12"
               gradientUnits="userSpaceOnUse" x1="-41.931332" y1="41.009075" x2="84.185104" y2="41.009075"
               gradientTransform="translate(-20.667384,6.0279871)" />
            <linearGradient inkscape:collect="always" xlink:href="#swatch11" id="linearGradient13"
               gradientUnits="userSpaceOnUse" gradientTransform="translate(-19.223114,69.488021)" x1="-41.931332"
               y1="41.009075" x2="84.185104" y2="41.009075" />
            <linearGradient inkscape:collect="always" xlink:href="#swatch11" id="linearGradient14"
               gradientUnits="userSpaceOnUse" gradientTransform="translate(241.70261,66.904598)" x1="-41.931332"
               y1="41.009075" x2="84.185104" y2="41.009075" />
            <linearGradient inkscape:collect="always" xlink:href="#swatch11" id="linearGradient15"
               gradientUnits="userSpaceOnUse" gradientTransform="translate(238.53606,4.3057051)" x1="-41.931332"
               y1="41.009075" x2="84.185104" y2="41.009075" />
            <linearGradient inkscape:collect="always" xlink:href="#swatch11" id="linearGradient16"
               gradientUnits="userSpaceOnUse" gradientTransform="translate(518.40689,3.4445641)" x1="-41.931332"
               y1="41.009075" x2="84.185104" y2="41.009075" />
            <linearGradient inkscape:collect="always" xlink:href="#swatch11" id="linearGradient17"
               gradientUnits="userSpaceOnUse" gradientTransform="translate(497.7395,2.5834231)" x1="-41.931332"
               y1="41.009075" x2="84.185104" y2="41.009075" />
            <symbol id="g10">

               <style>
                  /* Define fill using CSS variables with defaults */
                  /* Add a common class for other styling if needed */
                  .table-rect-common {
                     opacity: 0.860725;
                     stroke: none;
                     stroke-width: 0.331272;
                     stroke-linecap: round;
                     stroke-linejoin: round;
                     stroke-dasharray: 0.331272, 0.993814;
                     stroke-dashoffset: 0.331272;
                     stroke-opacity: 0.890196;
                     paint-order: fill markers stroke;
                  }

                  /* Target specific rects by ID and set their fill variable */
                  #symbol-tableA {
                     fill: var(--table-a-fill, white);
                  }

                  #symbol-tableB {
                     fill: var(--table-b-fill, white);
                  }

                  #symbol-tableC {
                     fill: var(--table-c-fill, white);
                  }
               </style>

               <g id="g7" inkscape:label="simpleSwitch">
                  <rect style="opacity:0.860725;fill:#b3b3b3;stroke:#000;stroke-width:3.0164;stroke-linecap:round;stroke-linejoin:round;stroke-opacity:0.890196;paint-order:fill markers stroke" id="rect3" x="629.01556" rx="4.4060531" ry="8.2601871" inkscape:label="switchContainer" height="150" width="200" y="150"></rect>
                  
                  
                  
                  <rect style="opacity:0.860725;fill:var(--colors-8);stroke:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke-dasharray:2, 6;stroke-dashoffset:2;stroke-opacity:0.890196;paint-order:fill markers stroke;
                     display:var(--show-inference, inline);" id="rect4" width="140" x="660" rx="4" ry="4" inkscape:label="inferenceBlock" height="45" y="170"></rect>
                  <text xml:space="preserve" id="text7-3" inkscape:label="inferenceLabel" y="190" style="font-family:arial;-inkscape-font-specification:arial;text-align:start;writing-mode:lr-tb;direction:ltr;text-anchor:start;opacity:0.860725;fill:#ffcc00;fill-opacity:1;stroke:none;stroke-width:0;stroke-linecap:round;stroke-linejoin:round;stroke-dasharray:none;stroke-opacity:0.581339;paint-order:fill markers stroke;
                     display:var(--show-inference, inline);" x="685">
                     <tspan sodipodi:role="line" id="tspan7-6" x="685" y="198" style="font-size:23px;fill:#000000">Inference</tspan>
                  </text>
                  <rect style="opacity:0.860725;fill:var(--colors-10);stroke:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke-dasharray:2, 6;stroke-dashoffset:2;stroke-opacity:0.890196;paint-order:fill markers stroke" id="rect5" width="140" x="660"  rx="4" ry="4" inkscape:label="forwardBlock" height="45" y="235"></rect>
                  <text xml:space="preserve" style="font-size:21.3333px;font-family:arial;-inkscape-font-specification:arial;text-align:start;writing-mode:lr-tb;direction:ltr;text-anchor:start;display:inline;opacity:0.860725;fill:#ffcc00;fill-opacity:1;stroke:none;stroke-width:0;stroke-linecap:round;stroke-linejoin:round;stroke-dasharray:none;stroke-opacity:0.581339;paint-order:fill markers stroke" x="692.9364" id="text7" inkscape:label="forwardLabel" y="240">
                     <tspan sodipodi:role="line" id="tspan7" x="690" y="265" style="font-size:23px;fill:#000000">Forward</tspan>
                  </text><rect style="opacity:0.860725;stroke:none;stroke-width:0.331272;stroke-linecap:round;stroke-linejoin:round;stroke-dasharray:0.331272, 0.993814;stroke-dashoffset:0.331272;stroke-opacity:0.890196;paint-order:fill markers stroke;
                        display:var(--show-registers, inline);" id="symbol-tableA" class="table-rect-common" rx="1.029658" ry="0.4263173" inkscape:label="tableA" x="660" width="15" y="235" height="15"></rect><rect style="opacity:0.860725;stroke:none;stroke-width:0.331272;stroke-linecap:round;stroke-linejoin:round;stroke-dasharray:0.331272, 0.993814;stroke-dashoffset:0.331272;stroke-opacity:0.890196;paint-order:fill markers stroke;
                        display:var(--show-registers, inline);" id="symbol-tableB" class="table-rect-common" inkscape:label="tableB" rx="1.029658" ry="0.4263173" x="660" width="15" y="250" height="15"></rect><rect style="opacity:0.860725;stroke:none;stroke-width:0.331272;stroke-linecap:round;stroke-linejoin:round;stroke-dasharray:0.331272, 0.993814;stroke-dashoffset:0.331272;stroke-opacity:0.890196;paint-order:fill markers stroke;
                        display:var(--show-registers, inline);" id="symbol-tableC" class="table-rect-common" rx="1.029658" ry="0.4263173" inkscape:label="tableC" x="660" width="15" height="15" y="265"></rect>
                  
               </g>
            </symbol>
            <symbol id="animated-switch-symbol">
               <title id="title2">Switch</title>
               <style id="style2">
                  @keyframes blinkSlowAnim {

                     0%,
                     100% {
                        fill: #00ff00;
                     }

                     50% {
                        fill: #333300;
                     }
                  }

                  @keyframes blinkFastAnim {

                     0%,
                     100% {
                        fill: #00ff00;
                     }

                     50% {
                        fill: #333300;
                     }
                  }

                  .led-slow {
                     animation: blinkSlowAnim 1.5s infinite;
                  }

                  .led-fast {
                     animation: blinkFastAnim 0.5s infinite;
                  }

                  .switch-body {
                     fill: #535353;
                     stroke: #afafaf;
                     stroke-width: 1;
                  }

                  .port {
                     fill: #282828;
                     stroke: #555;
                     stroke-width: 0.5;
                  }

                  .led {
                     /* Estilos base del LED */
                  }

                  .led-on {
                     fill: #00ff00;
                  }

                  .led-off {
                     fill: #333300;
                  }

                  .label-text {
                     font-family: Arial, sans-serif;
                     font-size: 10px;
                     fill: #e9e8e8;
                     text-anchor: start;
                  }
               </style>
               <rect class="switch-body" x="5" y="10" width="170" height="50" rx="4" ry="4" id="rect2" />
               <g id="g11" inkscape:label="g11">
                  <!-- LEDs -->
                  <!-- Puerto 1 -->
                  <!-- Puerto 2 -->
                  <!-- Puerto 3 -->
                  <g id="g40" inkscape:label="leds" transform="translate(-10,22)" style="display:inline">
                     <circle class="led led-on" cx="27.5" cy="20" r="2.5" id="circle5" style="display:none" />
                     <circle class="led led-off" cx="47.5" cy="20" r="2.5" id="circle6" style="display:none" />
                     <circle class="led led-off" cx="67.5" cy="20" r="2.5" id="circle7" style="display:none" />
                     <circle class="led led-on" cx="87.5" cy="20" r="2.5" id="circle8" style="display:none" />
                     <circle class="led led-on" cx="178.90355" cy="-6.5233498" r="2.5" id="circle42" />
                  </g>
                  <!-- Puerto 4 -->
                  <!-- Puertos RJ45 -->
                  <g id="g41" inkscape:label="inference-block">
                     <path
                        style="display:none;opacity:0.860725;fill:none;fill-opacity:1;stroke:#d3d2b9;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke-dasharray:none;stroke-opacity:0.890196;paint-order:fill markers stroke"
                        d="M 16.35184,45.66341 C 17.109564,34.50745 22.229009,26.173781 30.6297,19.96327 h 53.99626 c 8.694015,6.753331 10.838061,16.372273 12.46068,26.21934"
                        id="path42" sodipodi:nodetypes="cccc" inkscape:label="inference-path" />
                     <rect
                        style="opacity:0.860725;fill:#ffcc00;fill-opacity:1;stroke:none;stroke-width:0;stroke-linecap:round;stroke-linejoin:round;stroke-dasharray:none;stroke-opacity:0.581339;paint-order:fill markers stroke"
                        id="rect40-6" width="55" height="13.175277" x="30.537067" y="13.994616" rx="6.2733111"
                        ry="0.89086002" inkscape:label="inference-block-label" />
                     <text xml:space="preserve"
                        style="font-size:8px;font-family:arial;-inkscape-font-specification:arial;text-align:start;writing-mode:lr-tb;direction:ltr;text-anchor:start;opacity:0.860725;fill:#ffcc00;fill-opacity:1;stroke:none;stroke-width:0;stroke-linecap:round;stroke-linejoin:round;stroke-dasharray:none;stroke-opacity:0.581339;paint-order:fill markers stroke"
                        x="41.152302" y="23.447489" id="text41">
                        <tspan sodipodi:role="line" id="tspan41" x="41.152302" y="23.447489"
                           style="font-size:8px;fill:#000000">Inference</tspan>
                     </text>
                  </g>
                  <g id="g42" inkscape:label="fordwarding-block">
                     <path
                        style="display:inline;opacity:0.860725;fill:none;fill-opacity:1;stroke:#d3d2b9;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke-dasharray:none;stroke-opacity:0.888787;paint-order:fill markers stroke"
                        d="M 16.180276,45.044705 C 16.938,33.888745 30.659739,35.169404 30.458136,35.199773 h 53.99626 c 0,0 10.83806,0.517065 12.46068,10.364132"
                        id="path42-5" sodipodi:nodetypes="cccc" inkscape:label="fordwarding-path" />
                     <rect
                        style="opacity:0.860725;fill:#6ed371;fill-opacity:1;stroke:none;stroke-width:0;stroke-linecap:round;stroke-linejoin:round;stroke-dasharray:none;stroke-opacity:0.581339;paint-order:fill markers stroke"
                        id="rect40" width="55" height="13.175277" x="30.341879" y="28.784266" rx="6.2733111"
                        ry="0.89086002" inkscape:label="fordwarding-block-label" />
                     <text xml:space="preserve"
                        style="font-size:8px;font-family:arial;-inkscape-font-specification:arial;text-align:start;writing-mode:lr-tb;direction:ltr;text-anchor:start;opacity:0.860725;fill:#ffcc00;fill-opacity:1;stroke:none;stroke-width:0;stroke-linecap:round;stroke-linejoin:round;stroke-dasharray:none;stroke-opacity:0.581339;paint-order:fill markers stroke"
                        x="40.908287" y="38.188309" id="text41-7">
                        <tspan sodipodi:role="line" id="tspan41-5" x="40.908287" y="38.188309"
                           style="font-size:8px;fill:#000000">Fordward</tspan>
                     </text>
                  </g>
                  <g id="g39" inkscape:label="ports" transform="translate(-10,18)">
                     <rect class="port" x="19.921856" y="27.921856" width="15.031258" height="10.374435" rx="1.5031258"
                        ry="0.70734781" id="rect8" />
                     <rect class="port" x="39.963531" y="27.921856" width="15.031258" height="10.374435" rx="1.5031258"
                        ry="0.70734781" id="rect9" />
                     <rect class="port" x="60.005211" y="27.921856" width="15.031258" height="10.374435" rx="1.5031258"
                        ry="0.70734781" id="rect10" />
                     <rect class="port" x="80.04689" y="27.921856" width="15.031258" height="10.374435" rx="1.5031258"
                        ry="0.70734781" id="rect11" />
                     <rect class="port" x="99.21933" y="27.921619" width="15.031258" height="10.374435" rx="1.5031258"
                        ry="0.70734781" id="rect11-3" style="fill:#282828;stroke:#555555;stroke-width:0.5"
                        inkscape:label="rect12" />
                  </g>
               </g>
               <g id="g12" transform="translate(0,14)">
                  <text class="label-text" x="115" y="40" id="text11" inkscape:label="P4Label">SwitchP4</text>
               </g>
            </symbol>
         </defs>
         <g id="switch-layer" transform="translate(67.647795,3.8892291)">
            <!-- Instance Switch A -->
            <g id="switch-a" transform="matrix(0.99992533,0,0,0.99992533,49.997341,39.998601)">
               <!-- Instance label -->
               <use xlink:href="#g10" id="switchA" transform="translate(-663.1128,-119.64015)"
                  style="--show-registers: none" inkscape:label="switchA" />
               <text x="63.743423" y="10.844433" text-anchor="middle" font-family="Arial, sans-serif" font-size="18px"
                  fill="#dddddd" id="switch-label-a" data-name="Switch A" style="font-size:18px">Switch A</text>
            </g>
            <!-- Instance Switch B -->
            <g id="switch-b" transform="translate(291.32041,65.942477)">
               <!-- Instance label -->
               <text x="89.619743" y="-15.099602" text-anchor="middle" font-family="Arial, sans-serif" font-size="18px"
                  fill="#dddddd" id="switch-label-b" data-name="Switch B" style="font-size:18px">Switch B</text>
               <use xlink:href="#g10" id="switchB" transform="translate(-637.56464,-145.5899)"
                  style="--show-inference: none; --show-registers: none;" inkscape:label="switchB" />
            </g>
            <!-- Instance Switch C -->
            <g id="switch-c" transform="translate(570,65.942477)">
               <!-- Instance label -->
               <text x="77.726685" y="-15.099602" text-anchor="middle" font-family="Arial, sans-serif" font-size="18px"
                  fill="#dddddd" id="switch-label-c" data-name="Switch C" style="font-size:18px">Switch C</text>
               <use xlink:href="#g10" id="switchC" transform="translate(-649.37566,-145.5899)"
                  style="--show-inference: none; --show-registers: none" inkscape:label="swithcC" />
            </g>
         </g>
         <g inkscape:groupmode="layer" id="layer1" inkscape:label="Cable layer" transform="translate(41.931325,3.8892291)">
            <path style="opacity:0.9;fill:#4d4d4d;fill-opacity:1;stroke:url(#linearGradient11);stroke-width:8;stroke-linecap:round;stroke-linejoin:round;stroke-dasharray:none;stroke-opacity:1;paint-order:fill markers stroke" id="cable-0" inkscape:label="Cable0" sodipodi:nodetypes="cc" d="m -58.895148,145 102.092771,0"></path><path style="opacity:0.9;fill:none;fill-opacity:1;stroke:url(#linearGradient13);stroke-width:8;stroke-linecap:round;stroke-linejoin:round;stroke-dasharray:none;stroke-opacity:1;paint-order:fill markers stroke" id="cable-a-b" inkscape:label="CableA-B" sodipodi:nodetypes="cc" d="M 310.43104,145 H 235.8953"></path>
            <path style="opacity:0.9;fill:none;fill-opacity:1;stroke:url(#linearGradient14);stroke-width:8;stroke-linecap:round;stroke-linejoin:round;stroke-dasharray:none;stroke-opacity:1;paint-order:fill markers stroke" id="cable-b-c" inkscape:label="CableB-C" sodipodi:nodetypes="cc" d="M 580.60558,145 H 503.68785"></path>
            <path style="opacity:0.9;fill:none;fill-opacity:1;stroke:url(#linearGradient16);stroke-width:8;stroke-linecap:round;stroke-linejoin:round;stroke-dasharray:none;stroke-opacity:1;marker-end:url(#Square);paint-order:fill markers stroke" id="cable-d-out" inkscape:label="CableC-out" sodipodi:nodetypes="cc" d="m 862.42127,145 -89.93622,-1.00376"></path>
         </g>
         <path style="display:none;opacity:0.718;fill:none;fill-opacity:1;stroke:var(--red);stroke-width:4;stroke-linecap:square;stroke-linejoin:round;stroke-dasharray:none;stroke-opacity:0.969157;paint-order:fill markers stroke" id="package-path" inkscape:label="classD" sodipodi:nodetypes="cc" d="m -17.810889,148 921.524859,0.78692"></path>
         <!-- Capa para los paquetes animados (DEBE ESTAR DESPUÃ‰S para verse encima) -->
         <g id="packet-layer" transform="translate(0,0)">
            <!-- packets will be here -->
         </g>
      </svg>




   </div>

   <script>



      document.addEventListener('DOMContentLoaded', function () {

         let activePacketAnimations = [];
         window.parent.isAnimationPaused = false;
         let isPaused = false;

         const svg = document.getElementById('network-svg');
         const packetLayer = document.getElementById('packet-layer');
         const NS = "http://www.w3.org/2000/svg";

         const packetClasses = ['A', 'C', 'E'];
         const packetDistributionConfig = {
            'A': 33,
            'C': 33,
            'E': 33,
         };

         const animationDuration = 12000; // ms
         const minInterval = 800;   // ms
         const maxInterval = 1400;  // ms
         const packetHeight = 16;
         const minPacketWidth = 20;
         const maxPacketWidth = 26;
         const inferenceOffsetY = -30;
         const forwardOffsetY = 30;

         const classificationCounts = {
            'A': 0,
            'C': 0,
            'E': 0
         };

         const switchEntryAndExit = {
            'switch-a': { entry: 15, exit: 29 },
            'switch-b': { entry: 43, exit: 57 },
            'switch-c': { entry: 72, exit: 86 }
         };

         const classToTableLabel = {
            'A': 'tableA',
            'C': 'tableB',
            'E': 'tableC'
         };

         const classifyThreshold = -1;
         const classConfig = {
            'A': {
               colorClass: 'classified-A',
               classifyThreshold: classifyThreshold,
               behavior: {
                  'switch-a': { action: 'inference' },
                  'switch-b': { action: 'forward' },
                  'switch-c': { action: 'forward' }
               },
               classificationSwitch: 'switch-a'
            },
            'C': {
               colorClass: 'classified-C',
               classifyThreshold: classifyThreshold,
               behavior: {
                  'switch-a': { action: 'forward' },
                  'switch-b': { action: 'forward' },
                  'switch-c': { action: 'forward' }
               },
               classificationSwitch: 'switch-a'
            },
            'E': {
               colorClass: 'classified-E',
               classifyThreshold: classifyThreshold,
               behavior: {
                  'switch-a': { action: 'forward' },
                  'switch-b': { action: 'forward' },
                  'switch-c': { action: 'forward' }
               },
               classificationSwitch: 'switch-a'
            }
         };

         const mainPathId = 'package-path';

         function getRandomClassWithDistribution() {
            const rand = Math.random() * 100;
            let cumulativePercentage = 0;
            const validClasses = Object.keys(packetDistributionConfig).filter(key => packetDistributionConfig[key] > 0);
            const totalPercentage = validClasses.reduce((sum, key) => sum + packetDistributionConfig[key], 0);

            for (const packetClass of validClasses) {
               cumulativePercentage += (packetDistributionConfig[packetClass] / totalPercentage) * 100; // Normalize percentage
               if (rand < cumulativePercentage) {
                  return packetClass;
               }
            }
            return validClasses[validClasses.length - 1];
         }

         function getTableColoredDataAttribute(tableLabel) {
            if (!tableLabel) return null;
            return tableLabel.charAt(0).toLowerCase() + tableLabel.slice(1) + 'Colored';
         }

         // Get CSS variable name from table label
         function getTableCssVariable(tableLabel) {
            if (!tableLabel) return null;
            if (tableLabel === 'tableA') return '--table-a-fill';
            if (tableLabel === 'tableB') return '--table-b-fill';
            if (tableLabel === 'tableC') return '--table-c-fill';
            return null;
         }

         // Function to create and animate the ping ---
         function createPingAnimation(targetGroup, color, yOffset) {
            const pingCircle = document.createElementNS(NS, 'circle');
            pingCircle.setAttribute('class', 'packet-ping');
            pingCircle.setAttribute('cx', '0');
            pingCircle.setAttribute('cy', '0');
            pingCircle.setAttribute('r', '0');
            pingCircle.setAttribute('fill', 'none');
            pingCircle.setAttribute('stroke', color);
            pingCircle.setAttribute('stroke-width', '8');
            pingCircle.setAttribute('opacity', '1');
            pingCircle.setAttribute('transform', `translate(0, ${yOffset})`);

            // Add the circle to the packet's group so it inherits position/rotation
            targetGroup.appendChild(pingCircle);

            // Animate the ping circle
            anime({
               targets: pingCircle,
               r: 25,
               opacity: 0,
               strokeWidth: 0,
               duration: 1800,
               easing: 'easeOutExpo',
               complete: function (anim) {
                  pingCircle.remove();
               }
            });
         }

         function createAndAnimatePacket() {
            const packetClass = getRandomClassWithDistribution();
            const config = classConfig[packetClass];
            const pathElement = document.getElementById(mainPathId);

            if (!config) {
               console.error(`Configuration for packet class ${packetClass} not found.`);
               scheduleNextPacket();
               return;
            }
            if (!pathElement) {
               console.error(`Main path with ID ${mainPathId} not found.`);
               scheduleNextPacket();
               return;
            }

            // --- Create group ---
            const packetGroup = document.createElementNS(NS, 'g');
            packetGroup.setAttribute('class', 'packet-group');

            const packetRect = document.createElementNS(NS, 'rect');
            const randomWidth = minPacketWidth + Math.random() * (maxPacketWidth - minPacketWidth);

            packetRect.setAttribute('class', 'packet');
            packetRect.setAttribute('width', randomWidth);
            packetRect.setAttribute('height', packetHeight);
            packetRect.setAttribute('x', -randomWidth / 2);
            packetRect.setAttribute('y', -packetHeight / 2);
            packetRect.setAttribute('rx', packetHeight / 4);
            packetRect.setAttribute('ry', packetHeight / 4);

            packetGroup.dataset.classified = 'false';
            packetGroup.dataset.packetClass = packetClass;
            packetGroup.dataset.previousSwitchId = 'none';
            packetGroup.dataset.committedOffsetY = 0;

            // Estruct: g > rect
            packetGroup.appendChild(packetRect);
            packetLayer.appendChild(packetGroup);
            // --- End creating group ---


            const motionPath = anime.path(pathElement);

            const packetAnimation = anime({
               targets: packetGroup,
               translateX: motionPath('x'),
               translateY: motionPath('y'),
               rotate: motionPath('angle'),
               easing: 'linear',
               duration: animationDuration,
               loop: false,
               autoplay: !isPaused,
               update: function (anim) {
                  const currentGroup = anim.animatables[0]?.target;
                  if (!currentGroup) return;
                  const currentRect = currentGroup.querySelector('rect.packet');
                  if (!currentRect) return;

                  const pClass = currentGroup.dataset.packetClass;
                  const classConf = classConfig[pClass];
                  const currentProgress = anim.progress;
                  let packetIsClassified = currentGroup.dataset.classified === 'true'; // Current state of packet

                  // --- Retrieve stored state ---
                  let previousSwitchId = currentGroup.dataset.previousSwitchId;
                  let committedOffsetY = parseFloat(currentGroup.dataset.committedOffsetY);

                  // --- 1. Determine current location ---
                  let currentSwitchId = null;
                  let isInSwitch = false;
                  for (const switchId in switchEntryAndExit) {
                     if (currentProgress >= switchEntryAndExit[switchId].entry &&
                        currentProgress <= switchEntryAndExit[switchId].exit) {
                        currentSwitchId = switchId;
                        isInSwitch = true;
                        break;
                     }
                  }

                  // --- 2. Handle Logic Based on Location (Inside Switch / Outside) ---
                  let yOffset = 0; // The offset to apply THIS frame

                  if (isInSwitch) {
                     const targetSwitchElement = document.getElementById(currentSwitchId);
                     const isClassificationSwitch = (currentSwitchId === classConf.classificationSwitch);
                     const threshold = classConf.classifyThreshold;
                     const currentCount = classificationCounts[pClass]; // Global count for this class
                     const tableLabel = classToTableLabel[pClass];

                     // --- A. Entered a NEW switch this frame? ---
                     if (currentSwitchId !== previousSwitchId) {
                        // --- Determine the initial path FOR THIS VISIT based on state AT ENTRY ---
                        let initialAction; // Start undefined

                        // Get the configured action for this specific switch, default to 'forward' if undefined
                        const configuredAction = classConf.behavior[currentSwitchId] ? classConf.behavior[currentSwitchId].action : 'forward';

                        // --- Apply Path Decision Rules ---

                        // Rule 1: If packet is ALREADY classified upon entering ANY switch, it always forwards.
                        if (packetIsClassified) {
                           initialAction = 'forward';
                        }
                        // Rule 2 & 3: If entering its designated CLASSIFICATION switch...
                        else if (isClassificationSwitch) {
                           if (currentCount >= threshold && threshold > 0) {
                              initialAction = 'forward';
                           } else {
                              initialAction = 'inference'; // Rule 3: Threshold not met, take inference path (will infer/color mid-switch)
                           }
                        }
                        // Rule 4 & 5: If entering a switch BEFORE its classification switch...
                        else {
                           initialAction = configuredAction; // Use the action defined in classConfig for this switch
                        }
                        // --- End Path Decision Rules ---

                        // Lock the offset for this switch visit
                        committedOffsetY = (initialAction === 'inference') ? inferenceOffsetY : forwardOffsetY;
                        currentGroup.dataset.committedOffsetY = committedOffsetY;
                        currentGroup.dataset.previousSwitchId = currentSwitchId; // Mark entry into this switch

                        yOffset = committedOffsetY; // Use the newly committed offset immediately

                        // Handle subsequent switch table coloring ON ENTRY (if packet was already classified)
                        if (packetIsClassified && !isClassificationSwitch && targetSwitchElement && tableLabel) {
                           const dataAttributeName = getTableColoredDataAttribute(tableLabel);
                           if (dataAttributeName && targetSwitchElement.dataset[dataAttributeName] !== 'true') {
                              const targetColor = getComputedStyle(document.documentElement).getPropertyValue(`--class-${pClass}`).trim();
                              const variableName = getTableCssVariable(tableLabel);
                              if (variableName && targetColor) {
                                 targetSwitchElement.style.setProperty(variableName, targetColor);
                                 targetSwitchElement.dataset[dataAttributeName] = 'true';
                              }
                           }
                        }

                     } else {
                        // --- B. Still inside the SAME switch ---
                        // Use the offset that was committed upon entry
                        yOffset = committedOffsetY;

                        // Perform MID-SWITCH classification logic (if applicable), but WITHOUT changing path
                        if (isClassificationSwitch && !packetIsClassified) {
                           // Determine the point at which classification visually happens
                           // Use midpoint for inference path, slightly after entry for forward path
                           const midProgressPoint = committedOffsetY === inferenceOffsetY ? // Check committed path!
                              (switchEntryAndExit[currentSwitchId].entry + switchEntryAndExit[currentSwitchId].exit) / 2 :
                              (switchEntryAndExit[currentSwitchId].entry + 3); // Point for packets forced forward by threshold

                           if (currentProgress >= midProgressPoint) {
                              // --- Classification happens here ---
                              packetIsClassified = true; // Update local flag
                              currentGroup.dataset.classified = 'true'; // Persist on packet
                              currentRect.classList.add(classConf.colorClass);

                              // PING ANIMATION TRIGGER
                              const packetColor = getComputedStyle(document.documentElement)
                                 .getPropertyValue(`--class-${pClass}`).trim();
                              if (packetColor) {
                                 createPingAnimation(currentGroup, packetColor, yOffset); // Call the helper
                              }
                              // END: PING ANIMATION TRIGGER

                              if (currentCount < threshold) {
                                 classificationCounts[pClass]++;

                                 // Check if THIS classification just hit the threshold - color table
                                 if (classificationCounts[pClass] === threshold) {
                                    const variableName = getTableCssVariable(tableLabel);
                                    const targetColor = getComputedStyle(document.documentElement).getPropertyValue(`--class-${pClass}`).trim();
                                    if (targetSwitchElement && variableName && targetColor) {
                                       targetSwitchElement.style.setProperty(variableName, targetColor);
                                       const dataAttrName = getTableColoredDataAttribute(tableLabel);
                                       if (dataAttrName) targetSwitchElement.dataset[dataAttrName] = 'true';
                                    }
                                 }
                              } else {
                                 // This branch handles the case where threshold was already met, but the packet
                                 // started this switch visit unclassified (and took the 'forward' path due to Rule 2)
                                 // Now it just gets colored.
                              }
                              // Packet is now colored, but yOffset remains locked to committedOffsetY
                           }
                        } // End if (isClassificationSwitch && !packetIsClassified)
                     } // End if/else (New switch vs Same switch)

                  } else {
                     // --- C. Outside any switch ---
                     yOffset = 0;

                     // Reset state if it just exited a switch
                     if (previousSwitchId !== 'none') {
                        currentGroup.dataset.previousSwitchId = 'none';
                        currentGroup.dataset.committedOffsetY = yOffset; // Store default offset
                        previousSwitchId = 'none'; // Update local var for this frame
                     }
                  } // End if/else (isInSwitch)

                  // --- 3. Apply the determined Transform ---
                  currentRect.setAttribute('transform', `translate(0, ${yOffset})`);

               }, // --- end update ---
               complete: function (anim) {
                  // --- Remove from tracking array ---
                  const index = activePacketAnimations.indexOf(anim);
                  if (index > -1) {
                     activePacketAnimations.splice(index, 1);
                  }
                  // --- Remove element ---
                  const finishedGroup = anim.animatables[0]?.target;
                  if (finishedGroup) {
                     finishedGroup.remove();
                  }
               }
            }); // end anime

            activePacketAnimations.push(packetAnimation);


         }

         function scheduleNextPacket() {

            if (window.parent.isAnimationPaused) {
               if (!isPaused) {
                  [...activePacketAnimations].forEach(animInstance => {
                     if (animInstance && !animInstance.paused) {
                        animInstance.pause();
                     }
                  });
                  window.parent.isAnimationPaused = true;
                  isPaused = true;
                  console.log('Animations Paused (Creation Halted)');
                  // No need to call scheduleNextPacket here, loop stops itself
               }
            }
            else {
               if (isPaused) {
                  isPaused = false; // Set state FIRST
                  [...activePacketAnimations].forEach(animInstance => {
                     if (animInstance && animInstance.paused) {
                        animInstance.play();
                     }
                  });
                  console.log('Animations Played (Creation Resumed)');
               }
            }


            // 1. Check Pause State
            if (isPaused) {
               // If paused, just check again later. Don't create packet.
               setTimeout(scheduleNextPacket, maxInterval); // Check periodically
               return;
            }

            // 2. Check Packet Limit
            // Query *inside* scheduleNextPacket to get current count
            const animatedPackets = packetLayer.querySelectorAll('g.packet-group');
            if (animatedPackets.length >= 20) {
               console.warn(`Packet limit (${animatedPackets.length}) reached. Waiting...`);
               // Wait a bit longer before checking limit again
               setTimeout(scheduleNextPacket, 1000);
               return;
            }

            // 3. Calculate Delay and Schedule Creation
            const randomInterval = minInterval + Math.random() * (maxInterval - minInterval);
            setTimeout(() => {
               // Double-check pause state *before* creating
               if (!isPaused) {
                  createAndAnimatePacket(); // Create the packet
               }
               // IMPORTANT: Whether created or not (due to pause), schedule the *next* check/creation attempt.
               scheduleNextPacket();
            }, randomInterval);


         } // --- END scheduleNextPacket --- // --- Button Controllers (Logic looks correct now) ---
         const playButton = document.getElementById('play-button');
         const pauseButton = document.getElementById('pause-button');

         scheduleNextPacket();

      });
   </script>

</body>

</html>